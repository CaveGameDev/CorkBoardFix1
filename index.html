<html>
<head>
  <title>Cork Board</title>
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
  <style>
    body {
      margin: 0;
      background-color: #333; 
      font-family: Arial, sans-serif;
      overflow: hidden; 
      touch-action: none; 
    }

    #darkness-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: black;
      z-index: 999; 
      pointer-events: none; 
      opacity: 0; 
      transition: opacity 0.5s ease-out; 
    }
    
    #viewport {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      cursor: grab; 
      touch-action: none; 
    }

    #viewport.dragging {
      cursor: grabbing; 
    }
    
    #corkboard {
      position: absolute;
      padding: 20px;
      box-shadow: 
        inset 0 0 50px rgba(0,0,0,0.5);
      transform-origin: top left; 
      background-image: url('cork_texture_large.png'); 
      background-repeat: repeat;
      background-size: 1024px 1024px; 
      touch-action: none; 
    }

    .post-it {
      background: linear-gradient(145deg, #feff9c 0%, #fff6a6 100%);
      padding: 15px;
      width: 200px;
      min-height: 150px;
      position: absolute;
      box-shadow: 
        2px 2px 8px rgba(0,0,0,0.2),
        0 0 40px rgba(0,0,0,0.1);
      transform: rotate(var(--rotation)); 
      transition: box-shadow 0.2s;
      cursor: grab; 
      z-index: 1;
      touch-action: none; 
      display: flex; 
      flex-direction: column; 
    }

    .post-it:hover {
      transform: scale(1.05) rotate(var(--rotation));
      z-index: 1000;
      box-shadow: 
        5px 5px 15px rgba(0,0,0,0.3),
        0 0 40px rgba(0,0,0,0.2);
    }
    
    .post-it:active {
      cursor: grabbing; 
    }

    .post-it.selected {
      outline: 3px solid #4CAF50;
      z-index: 2000;
    }

    .post-it .username {
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 14px;
    }

    .post-it .text {
      font-family: 'Comic Sans MS', cursive;
      font-size: 16px;
      white-space: pre-wrap;
      flex-grow: 1; 
      overflow: auto; 
      min-height: 50px; 
    }

    .post-it .text a { 
        color: #007bff; 
        text-decoration: underline;
        word-break: break-all; 
    }
    .post-it .text a:hover {
        color: #0056b3;
    }

    .post-it .note-image {
      max-width: 100%;
      height: auto;
      display: block; 
      margin-top: 8px; 
      border-radius: 4px;
      object-fit: contain; 
    }

    .note-pile {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 220px;
      z-index: 1000;
      touch-action: auto; 
    }

    .new-note {
      background: linear-gradient(145deg, #feff9c 0%, #fff6a6 100%);
      padding: 15px;
      width: 200px;
      min-height: 180px; 
      box-shadow: 
        0 0 10px rgba(0,0,0,0.2),
        0 5px 15px rgba(0,0,0,0.1);
      margin-bottom: 0; 
      cursor: text;
      position: relative;
      transition: transform 0.2s, box-shadow 0.2s, background-color 0.2s; 
      touch-action: auto; 
      display: flex; 
      flex-direction: column; 
      justify-content: space-between; 
    }

    .new-note:hover {
      transform: translateY(-5px);
      box-shadow: 
        0 5px 15px rgba(0,0,0,0.3),
        0 10px 20px rgba(0,0,0,0.2);
    }

    .new-note.drag-over { 
        background: linear-gradient(145deg, #c7d163 0%, #d8e085 100%); 
        box-shadow: 0 0 15px rgba(0,255,0,0.5), 0 5px 20px rgba(0,255,0,0.3); 
    }

    .new-note textarea {
      width: 100%;
      height: auto; 
      flex-grow: 1; 
      border: none;
      background: transparent;
      resize: none;
      font-family: 'Comic Sans MS', cursive;
      font-size: 16px;
      touch-action: auto; 
      margin-bottom: 10px; 
    }

    .new-note textarea:focus {
      outline: none;
    }

    .new-note-actions {
      display: flex;
      flex-direction: column; 
      gap: 5px;
      margin-top: auto; 
    }

    .file-name-preview {
      font-size: 12px;
      color: #555;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-align: center;
      padding: 5px 0;
    }

    .note-form textarea {
      width: 200px;
      height: 100px;
      margin-bottom: 10px;
      font-family: 'Comic Sans MS', cursive;
    }

    button {
      padding: 8px 16px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      touch-action: auto; 
    }

    button:hover {
      background: #45a049;
    }
    
    button:disabled { 
      background: #888;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .new-note-actions button {
      padding: 10px 20px; 
      background: linear-gradient(to bottom, #7acc8c, #4CAF50); 
      border: 2px solid #3d8c40; 
      border-radius: 8px; 
      box-shadow: 0 4px 6px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.2);
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.4);
      transition: all 0.1s ease-out; 
    }

    .new-note-actions button:hover {
      background: linear-gradient(to bottom, #4CAF50, #7acc8c); 
      box-shadow: 0 6px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3);
      transform: translateY(-2px); 
    }

    .new-note-actions button:active {
      background: #45a049; 
      box-shadow: 0 2px 3px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.1);
      transform: translateY(0); 
    }

    .chat-container {
      position: fixed;
      top: 20px;
      left: 20px;
      width: 300px;
      height: 400px;
      background: rgba(50, 50, 50, 0.95);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      z-index: 2000;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      color: white;
      touch-action: auto; 
    }

    .chat-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 15px;
        background: rgba(40, 40, 40, 0.95);
        border-bottom: 1px solid #555;
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
        font-weight: bold;
    }

    .chat-minimize-button {
        background: none;
        border: none;
        color: white;
        font-size: 20px;
        cursor: pointer;
        line-height: 1; 
        padding: 0 5px;
    }
    
    .chat-minimize-button:hover {
        color: #ccc;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      display: flex;
      flex-direction: column-reverse; 
    }

    .chat-message {
      margin: 4px 0;
      padding: 8px;
      border-radius: 4px;
      max-width: 80%;
      word-wrap: break-word;
      color: white;
    }

    .chat-message.system {
      background: rgba(80, 80, 80, 0.8);
      align-self: center;
      font-style: italic;
    }

    .chat-message.self { 
      background: rgba(60, 120, 200, 0.8); 
      align-self: flex-end;
    }

    .chat-message.peer { 
      background: rgba(100, 100, 100, 0.8);
      align-self: flex-start;
    }

    .chat-message .username {
      font-weight: bold;
      margin-bottom: 4px;
      font-size: 13px;
      color: #add8e6; 
    }
    .chat-message.self .username {
        color: #fff; 
    }

    .chat-input {
      display: flex;
      padding: 10px;
      border-top: 1px solid #555;
    }

    .chat-input input {
      flex: 1;
      padding: 8px;
      border: 1px solid #555;
      border-radius: 4px;
      margin-right: 8px;
      background: rgba(60, 60, 60, 0.8);
      color: white;
      touch-action: auto; 
    }

    .chat-input input::placeholder {
      color: #aaa;
    }

    .chat-input button {
      padding: 8px 16px;
    }

    .chat-minimized-button {
      position: fixed;
      top: 20px;
      left: 20px;
      width: 40px;
      height: 40px;
      background: rgba(50, 50, 50, 0.95);
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      cursor: pointer;
      color: white;
      font-size: 24px;
      touch-action: auto;
    }

    .chat-minimized-button:hover {
      background: rgba(60, 60, 60, 0.95);
    }

    .archive-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.7); 
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 3000; 
      touch-action: auto; 
    }

    .archive-modal-content {
      background: rgba(50, 50, 50, 0.95); 
      border-radius: 8px;
      padding: 20px;
      width: 80%;
      max-width: 900px;
      height: 80%;
      display: flex;
      flex-direction: column;
      position: relative; 
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      color: white; 
    }

    .archive-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .archive-modal-header h3 {
      margin: 0;
      color: white;
    }

    .archive-modal-close {
      background: none;
      border: none;
      font-size: 24px;
      color: white;
      cursor: pointer;
      padding: 0 10px;
      touch-action: auto; 
    }

    .archive-modal-close:hover {
      color: #ccc;
    }

    .archive-list {
      flex: 1;
      overflow-y: auto; 
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); 
      gap: 15px;
      padding-right: 10px; 
    }

    .archive-preview-item {
      background: rgba(70, 70, 70, 0.8);
      border-radius: 4px;
      overflow: hidden;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      transition: transform 0.2s, box-shadow 0.2s;
      display: flex;
      flex-direction: column;
      touch-action: auto; 
    }

    .archive-preview-item:hover {
      transform: translateY(-3px);
      box-shadow: 0 5px 10px rgba(0,0,0,0.3);
    }

    .archive-preview-item img {
      width: 100%;
      height: 150px; 
      object-fit: cover;
      display: block;
    }

    .archive-timestamp {
      padding: 8px;
      font-size: 12px;
      color: #ccc;
      text-align: center;
    }

    .selected-archive-full-view {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 3001; 
      touch-action: pan-zoom; 
    }

    .selected-archive-full-view img {
      max-width: 90%;
      max-height: 90%;
      object-fit: contain;
    }

    .command-list-container {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(50, 50, 50, 0.95);
      border-radius: 8px;
      padding: 10px 15px;
      color: white;
      font-size: 14px;
      z-index: 2000;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      white-space: pre-wrap; 
      line-height: 1.5;
      pointer-events: none; 
    }

    .command-list-container strong {
      color: #add8e6; 
      font-weight: normal;
    }

    .command-minimized-button {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      background: rgba(50, 50, 50, 0.95);
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      cursor: pointer;
      color: white;
      font-size: 24px;
      touch-action: auto;
    }

    .command-minimized-button:hover {
      background: rgba(60, 60, 60, 0.95);
    }

    .command-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 3000;
      touch-action: auto;
    }

    .command-modal-content {
      background: rgba(50, 50, 50, 0.95);
      border-radius: 8px;
      padding: 20px;
      width: 90%; 
      max-width: 500px; 
      max-height: 80%; 
      overflow-y: auto; 
      display: flex;
      flex-direction: column;
      position: relative;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      color: white;
    }

    .command-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .command-modal-header h3 {
      margin: 0;
      color: white;
    }

    .command-modal-close {
      background: none;
      border: none;
      font-size: 24px;
      color: white;
      cursor: pointer;
      padding: 0 10px;
      touch-action: auto;
    }

    .command-modal-close:hover {
      color: #ccc;
    }

    @media (max-width: 767px) {
      .command-list-container {
        display: none; 
      }
    }
  </style>
</head>
<body>
  <iframe id="db-frame" src="Base.html" style="display:none;"></iframe>
  <div id="app"></div>
  <script type="text/babel">
    // DB and user setup
    const generateId = () => `${Date.now()}-${Math.random().toString(36).substr(2,9)}`;
    const username = localStorage.getItem('username')
      || prompt("Enter your username:", "Guest" + Math.floor(Math.random()*10000));
    localStorage.setItem('username', username);

    const audioList = [
      'Elevator Music.mp3',
      'The Great Strategy (2005) Roblox Theme 2006.mp3',
      'Sonic The Hedgehog OST - Green Hill Zone.mp3',
      'ROBLOX runaway.mp3',
      'Mii Editor - Mii Maker (Wii U) Music [ ezmp3.cc ].mp3',
      'omfg low quality.mp3',
      'Raise_A_Floppa_Soundtrack_[_YouConvert.net_].mp3',
      'Special Stage - Sonic the Hedgehog 3 [OST] - DeoxysPrime.mp3',
      'Super Mario 64 - Main Theme Music - Bob-Omb Battlefield [TubeRipper.com].mp3',
      'Coconut Mall - Mario Kart Wii OST.mp3',
      'Burger King Whopper Whopper Whopper Commercial But Its Low Quality.mp3',
      'c418-sweden-minecraft-volume-alpha.mp3',
      'Super Mario 64 Music - File Select EXTENDED.mp3',
      '02. Wasted Years.mp3',
    ].map(src => encodeURI(src));

    let currentTrackIndex = 0;
    const audio = new Audio();
    audio.src = audioList[0];
    audio.loop = false; 
    let isMusicUserPaused = false; 

    audio.addEventListener('ended', () => {
      currentTrackIndex = (currentTrackIndex + 1) % audioList.length;
      audio.src = audioList[currentTrackIndex];
      if (!isMusicUserPaused) { 
        audio.play().catch(err => console.warn("Audio play failed on next track:", err));
      }
    });

    const fluorescentBuzzAudio = new Audio(encodeURI('Fluorescent light Buzz.mp3'));
    fluorescentBuzzAudio.loop = true;
    fluorescentBuzzAudio.volume = 0.5; 

    const toggleAudio = () => {
      if (audio.paused) {
        audio.play().catch(err => console.warn("Audio play failed on toggle:", err));
        isMusicUserPaused = false;
      }
      else {
        audio.pause();
        isMusicUserPaused = true;
      }
    };

    const skipAudio = () => {
      if (audioList.length > 0) { 
        currentTrackIndex = (currentTrackIndex + 1) % audioList.length;
        audio.src = audioList[currentTrackIndex];
        audio.play().catch(err => console.warn("Audio play failed on skip:", err));
        isMusicUserPaused = false; 
      }
    };

    const attemptPlayAudio = () => {
      console.log("Attempting to play audio due to user interaction.");
      if (!isMusicUserPaused && audio.paused && fluorescentBuzzAudio.paused) {
        audio.play().catch(err => console.warn("Audio play failed:", err));
      } else if (fluorescentBuzzAudio.paused) { 
        // No explicit action needed if main audio is playing or user paused.
        // The point of this function is to kickstart audio if user interaction allows it.
      }
    };
    
    const shuffleArray = (array) => {
        let newArray = [...array];
        for (let i = newArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
        }
        return newArray;
    };

    function Chat({ chatMessages, onSendChat, onCommand, onMinimize, isMinimized, username }) {
      const [localMessages, setLocalMessages] = React.useState([]); 
      const [input, setInput] = React.useState('');
      const messagesEndRef = React.useRef(null);

      const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
      };

      React.useEffect(() => {
        scrollToBottom();
      }, [localMessages, chatMessages]);

      const handleSend = async () => {
        if (!input.trim()) return;
        
        attemptPlayAudio(); 
        
        const trimmedInput = input.trim();
        const AI_EMOJI_COMMAND_PREFIX = '!emoji ';

        if (trimmedInput.startsWith('!') || trimmedInput.startsWith('/')) {
            setLocalMessages(prev => [...prev, { type: 'user', text: trimmedInput }]);
            const command = trimmedInput.toLowerCase();
            if (command === '!pause') {
                onCommand('toggleMusic');
                setLocalMessages(prev => [...prev, { type: 'bot', text: 'Toggling music...' }]);
            } else if (command === '!skip') {
                onCommand('skipMusic');
                setLocalMessages(prev => [...prev, { type: 'bot', text: 'Skipping song...' }]);
            } else if (command === '/archive board') {
                onCommand('archive');
                setLocalMessages(prev => [...prev, { type: 'bot', text: 'Archiving current board state...' }]);
            } else if (command === '/archive view') {
                onCommand('viewArchives');
                setLocalMessages(prev => [...prev, { type: 'bot', text: 'Opening archives...' }]);
            } else {
                setLocalMessages(prev => [...prev, { type: 'bot', text: 'Command not recognized. Try !pause, !skip, /archive board, /archive view, or !emoji <expression>' }]);
            }
        } else {
            onSendChat(trimmedInput);
        }
        
        setInput('');
      };

      const allMessages = [
        ...localMessages.map(msg => ({ ...msg, type: msg.type === 'user' ? 'self' : msg.type })), 
        ...chatMessages.map(msg => ({
            ...msg,
            type: msg.username === username ? 'self' : 'peer' 
        }))
      ].sort((a, b) => new Date(a.created_at || 0) - new Date(b.created_at || 0)); 

      if (isMinimized) {
        return null; 
      }

      return (
        <div className="chat-container">
          <div className="chat-header">
            <span>Chat</span>
            <button className="chat-minimize-button" onClick={onMinimize}>&mdash;</button>
          </div>
          <div className="chat-messages">
            {allMessages.map((msg, i) => (
              <div key={msg.id || `local-${i}`} className={`chat-message ${msg.type}`}>
                {(msg.type === 'peer' || msg.type === 'self') && <div className="username">{msg.username}</div>}
                <div className="text">{msg.text}</div>
              </div>
            ))}
            <div ref={messagesEndRef} /> 
          </div>
          <div className="chat-input">
            <input
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyPress={(e) => {
                if (e.key === 'Enter') {
                  handleSend();
                }
              }}
              placeholder="Type a message or command..."
            />
            <button onClick={handleSend}>Send</button>
          </div>
        </div>
      );
    }

    function CorkBoard() {
      const [newNoteText, setNewNoteText] = React.useState('');
      const [selectedImageFile, setSelectedImageFile] = React.useState(null); 
      const [selectedVideoFile, setSelectedVideoFile] = React.useState(null); 
      const [selectedArchive, setSelectedArchive] = React.useState(null);
      const [showArchives, setShowArchives] = React.useState(false); 
      const [isChatMinimized, setIsChatMinimized] = React.useState(false); 
      const [isDragOver, setIsDragOver] = React.useState(false); 
      const [isGeneratingAIImage, setIsGeneratingAIImage] = React.useState(false); 
      
      const [isMobile, setIsMobile] = React.useState(window.innerWidth < 768);
      const [showCommandsAsModal, setShowCommandsAsModal] = React.useState(false);

      const [draggingNoteId, setDraggingNoteId] = React.useState(null);
      const [dragStartCoords, setDragStartCoords] = React.useState(null); 
      const [draggedNoteInitialPos, setDraggedNoteInitialPos] = React.useState(null); 
      const [currentDragOffset, setCurrentDragOffset] = React.useState({ x: 0, y: 0 });

      const [boardOffset, setBoardOffset] = React.useState({ x: 0, y: 0 }); 
      const [isBoardDragging, setIsBoardDragging] = React.useState(false);
      const [boardDragStartCoords, setBoardDragStartCoords] = React.useState(null); 
      const [initialBoardOffsetDuringDrag, setInitialBoardOffsetDuringDrag] = React.useState(null); 

      const [zoom, setZoom] = React.useState(1);
      const ZOOM_SPEED = 0.1;
      const MIN_ZOOM = 0.01; 
      const MAX_ZOOM = 1; 
      
      const ZOOM_THRESHOLD_FOR_DARKNESS = 0.15; 
      const ZOOM_THRESHOLD_FOR_AUDIO_CHANGE = 0.05; 

      const [isPinching, setIsPinching] = React.useState(false);
      const [initialPinchDistance, setInitialPinchDistance] = React.useState(0);
      const [initialPinchMidpoint, setInitialPinchMidpoint] = React.useState(null);
      const [initialBoardStateForPinch, setInitialBoardStateForPinch] = React.useState(null); 

      const boardStateRef = React.useRef({ offset: { x: 0, y: 0 }, zoom: 1 });

      const fileInputRef = React.useRef(null);

      boardStateRef.current = { offset: boardOffset, zoom: zoom };

      const [selectedNote, setSelectedNote] = React.useState(null); 
      const boardRef = React.useRef();
      const viewportRef = React.useRef();
      const darknessOverlayRef = React.useRef(); 

      // in-memory state
      const [notes, setNotes] = React.useState([]);
      const [chatMessages, setChatMessages] = React.useState([]);
      const [archives, setArchives] = React.useState([]);

React.useEffect(() => {
      const handleMessage = (e) => {
        const msg = e.data;
        if (msg?.type === 'BOARD_DATA') {
          const bd = msg.boardData || {};
          setNotes(bd.notes || []);
          setChatMessages(bd.chatMessages || []);
          setArchives(bd.archives || []);
          // Add this console log to verify if data is received by the parent
          console.log('Parent: Received BOARD_DATA. Notes count:', (bd.notes || []).length);
          console.log('Parent: Received BOARD_DATA. Chat messages count:', (bd.chatMessages || []).length);
        }
      };

      window.addEventListener('message', handleMessage);

      const frame = document.getElementById('db-frame');
      
      // Function to request data from the iframe once it's loaded
      const requestDataIfFrameLoaded = () => {
          if (frame && frame.contentWindow) {
              frame.contentWindow.postMessage({ type: 'REQUEST_BOARD' }, '*');
              console.log('Parent: Sent REQUEST_BOARD to iframe after iframe loaded.');
          }
      };

      if (frame) {
          // Check if the iframe is already loaded (e.g., due to browser cache)
          if (frame.contentWindow && frame.contentWindow.document.readyState === 'complete') {
              requestDataIfFrameLoaded();
          } else {
              // Otherwise, wait for the iframe's load event
              frame.onload = requestDataIfFrameLoaded;
          }
      }

      return () => {
        window.removeEventListener('message', handleMessage);
        // Clean up the iframe's onload handler to prevent memory leaks
        if (frame) {
            frame.onload = null; 
        }
      };
    }, []); // Empty dependency array means this runs once on mount
      
      React.useEffect(() => {
        const frame = document.getElementById('db-frame');
        if (frame) {
          frame.contentWindow.postMessage({
            type: 'SAVE_BOARD',
            boardData: { notes, chatMessages, archives }
          }, '*');
        }
      }, [notes, chatMessages, archives]);

      const handleSendChat = (text) => {
        const newMsg = {
          id: generateId(),
          text,
          username,
          created_at: new Date().toISOString()
        };
        setChatMessages(prev => [...prev, newMsg]);
      };

      const getClientCoords = (e, index = 0) => {
          if (e.touches && e.touches.length > index) {
              return { x: e.touches[index].clientX, y: e.touches[index].clientY };
          }
          if (e.changedTouches && e.changedTouches.length > index) {
              return { x: e.changedTouches[index].clientX, y: e.changedTouches[index].clientY };
          }
          return { x: e.clientX, y: e.clientY };
      };

      const getDistance = (p1, p2) => Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
      const getMidpoint = (p1, p2) => ({ x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 });

      React.useEffect(() => {
        const handleResize = () => {
          setIsMobile(window.innerWidth < 768);
        };
        window.addEventListener('resize', handleResize);
        
        setIsChatMinimized(window.innerWidth < 768);

        return () => window.removeEventListener('resize', handleResize);
      }, []); 

      React.useEffect(() => {
        const darknessOverlay = darknessOverlayRef.current;
        if (darknessOverlay) {
            let opacity = 0;
            if (zoom < ZOOM_THRESHOLD_FOR_DARKNESS) {
                opacity = 1 - (zoom - MIN_ZOOM) / (ZOOM_THRESHOLD_FOR_DARKNESS - MIN_ZOOM);
                opacity = Math.min(1, Math.max(0, opacity)); 
            }
            darknessOverlay.style.opacity = opacity;
        }

        if (zoom <= ZOOM_THRESHOLD_FOR_AUDIO_CHANGE) {
          audio.pause();
          if (fluorescentBuzzAudio.paused) {
            fluorescentBuzzAudio.play().catch(err => console.warn("Buzz audio play failed:", err));
          }
        } else {
          fluorescentBuzzAudio.pause();
          if (!isMusicUserPaused && audio.paused) { 
            audio.play().catch(err => console.warn("Main audio resume failed:", err));
          }
        }
      }, [zoom, isMusicUserPaused, ZOOM_THRESHOLD_FOR_DARKNESS, ZOOM_THRESHOLD_FOR_AUDIO_CHANGE, MIN_ZOOM]);

      React.useEffect(() => {
        const MOVE_SPEED = 20;
        const NOTE_MOVE_SPEED = 10;

        const handleKeyDown = (e) => {
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || showCommandsAsModal || showArchives || selectedArchive) {
            return;
          }

          if (e.key === 'Escape') {
            if (selectedArchive) { 
              setSelectedArchive(null);
              e.preventDefault();
              return;
            }
            if (showArchives) { 
              setShowArchives(false);
              e.preventDefault();
              return;
            }
            if (showCommandsAsModal) { 
              setShowCommandsAsModal(false);
              e.preventDefault();
              return;
            }
            if (selectedNote) { 
              setSelectedNote(null);
              e.preventDefault();
              return;
            }
            if (!isChatMinimized) { 
              setIsChatMinimized(true);
              e.preventDefault();
              return;
            }
          }

          if (selectedNote) {
            switch(e.key) {
              case 'ArrowLeft':
                updateNotePosition(selectedNote, -NOTE_MOVE_SPEED, 0);
                e.preventDefault();
                break;
              case 'ArrowRight':
                updateNotePosition(selectedNote, NOTE_MOVE_SPEED, 0);
                e.preventDefault();
                break;
              case 'ArrowUp':
                updateNotePosition(selectedNote, 0, -NOTE_MOVE_SPEED);
                e.preventDefault();
                break;
              case 'ArrowDown':
                updateNotePosition(selectedNote, 0, NOTE_MOVE_SPEED);
                e.preventDefault();
                break;
              case 'r':
                updateNoteRotation(selectedNote, (Math.random() - 0.5) * 10);
                e.preventDefault(); 
                break;
            }
          } else if (!showArchives && !selectedArchive && !isChatMinimized && !showCommandsAsModal) { 
            switch(e.key) {
              case 'ArrowLeft':
                setBoardOffset(pos => ({ ...pos, x: pos.x + MOVE_SPEED }));
                e.preventDefault();
                break;
              case 'ArrowRight':
                setBoardOffset(pos => ({ ...pos, x: pos.x - MOVE_SPEED }));
                e.preventDefault();
                break;
              case 'ArrowUp':
                setBoardOffset(pos => ({ ...pos, y: pos.y + MOVE_SPEED }));
                e.preventDefault();
                break;
              case 'ArrowDown':
                setBoardOffset(pos => ({ ...pos, y: pos.y - MOVE_SPEED }));
                e.preventDefault();
                break;
            }
          }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [selectedNote, boardOffset, showArchives, selectedArchive, isChatMinimized, showCommandsAsModal]);

      const updateNotePosition = (noteToUpdate, deltaX, deltaY) => {
        if (!noteToUpdate) return;
        const updatedPos = {
          x: (noteToUpdate.position?.x || 0) + deltaX,
          y: (noteToUpdate.position?.y || 0) + deltaY,
          rotation: noteToUpdate.position?.rotation || 0
        };
        setNotes(prev => prev.map(n =>
          n.id === noteToUpdate.id ? { ...n, position: updatedPos } : n
        ));
        setSelectedNote(prev => prev?.id === noteToUpdate.id
          ? { ...prev, position: updatedPos }
          : prev
        );
      };

      const updateNoteRotation = (noteToUpdate, rotationDelta) => {
        if (!noteToUpdate) return;
        const updatedPos = {
          x: noteToUpdate.position?.x || 0,
          y: noteToUpdate.position?.y || 0,
          rotation: (noteToUpdate.position?.rotation || 0) + rotationDelta
        };
        setNotes(prev => prev.map(n =>
          n.id === noteToUpdate.id ? { ...n, position: updatedPos } : n
        ));
        setSelectedNote(prev => prev?.id === noteToUpdate.id
          ? { ...prev, position: updatedPos }
          : prev
        );
      };

      const handleNoteMouseDown = (e, note) => {
        e.stopPropagation(); 
        e.preventDefault(); 
        setSelectedNote(note); 
        setDraggingNoteId(note.id);
        const { x, y } = getClientCoords(e);
        setDragStartCoords({ x, y });
        setDraggedNoteInitialPos(note.position);
        setCurrentDragOffset({ x: 0, y: 0 }); 
      };

      const handleBoardInteractionStart = (e) => {
        let currentTarget = e.target;
        while (currentTarget && currentTarget !== document.body) {
          if (currentTarget.classList.contains('chat-container') || currentTarget.classList.contains('chat-minimized-button') || 
              currentTarget.classList.contains('note-pile') || currentTarget.classList.contains('post-it') ||
              currentTarget.classList.contains('command-minimized-button') || currentTarget.classList.contains('command-modal-overlay')) {
            e.stopPropagation(); 
            return;
          }
          currentTarget = currentTarget.parentNode;
        }

        const isTargetValidForBoardInteraction = e.target.id === 'corkboard' || e.target.id === 'viewport';
        if (!isTargetValidForBoardInteraction) {
            return;
        }

        e.preventDefault(); 

        if (e.touches && e.touches.length === 2) {
            setIsPinching(true);
            const p1 = getClientCoords(e, 0);
            const p2 = getClientCoords(e, 1);
            setInitialPinchDistance(getDistance(p1, p2));
            setInitialPinchMidpoint(getMidpoint(p1, p2));
            setInitialBoardStateForPinch({ offset: boardStateRef.current.offset, zoom: boardStateRef.current.zoom });
            setSelectedNote(null); 
        } else if (e.touches && e.touches.length === 1 || e.type === 'mousedown') {
            setIsBoardDragging(true);
            const { x, y } = getClientCoords(e);
            setBoardDragStartCoords({ x, y });
            setInitialBoardOffsetDuringDrag(boardStateRef.current.offset); 
            setSelectedNote(null); 
        }
      };

      React.useEffect(() => {
        const handleBoardInteractionMove = (e) => {
          const { x: clientX, y: clientY } = getClientCoords(e);

          if (draggingNoteId && dragStartCoords && draggedNoteInitialPos) {
            e.preventDefault(); 
            const deltaX_screen = clientX - dragStartCoords.x;
            const deltaY_screen = clientY - dragStartCoords.y;
            
            const currentZoom = boardStateRef.current.zoom;
            const deltaX_world = deltaX_screen / currentZoom;
            const deltaY_world = deltaY_screen / currentZoom;

            setCurrentDragOffset({ x: deltaX_world, y: deltaY_world }); 
          } else if (isPinching && initialPinchDistance > 0 && initialPinchMidpoint && initialBoardStateForPinch) {
            e.preventDefault(); 
            if (e.touches && e.touches.length === 2) {
                const p1 = getClientCoords(e, 0);
                const p2 = getClientCoords(e, 1);
                const currentPinchDistance = getDistance(p1, p2);
                const currentPinchMidpoint = getMidpoint(p1, p2);

                const zoomFactor = currentPinchDistance / initialPinchDistance;
                let newZoom = initialBoardStateForPinch.zoom * zoomFactor;
                newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));
                newZoom = parseFloat(newZoom.toFixed(2)); 

                const worldMidX = (initialPinchMidpoint.x - initialBoardStateForPinch.offset.x) / initialBoardStateForPinch.zoom;
                const worldMidY = (initialPinchMidpoint.y - initialBoardStateForPinch.offset.y) / initialBoardStateForPinch.zoom;

                const newOffsetX = currentPinchMidpoint.x - (worldMidX * newZoom);
                const newOffsetY = currentPinchMidpoint.y - (worldMidY * newZoom);

                boardStateRef.current = { offset: { x: newOffsetX, y: newOffsetY }, zoom: newZoom };
                if (boardRef.current) {
                    boardRef.current.style.transform = `translate(${newOffsetX}px, ${newOffsetY}px) scale(${newZoom})`;
                }
            } else {
                // If one finger is lifted during pinch, stop pinching and board dragging
                setIsPinching(false);
                setIsBoardDragging(false); 
            }
          } else if (isBoardDragging && boardDragStartCoords && initialBoardOffsetDuringDrag) {
            e.preventDefault(); 
            const deltaX = clientX - boardDragStartCoords.x;
            const deltaY = clientY - boardDragStartCoords.y;
            
            const newX = initialBoardOffsetDuringDrag.x + deltaX;
            const newY = initialBoardOffsetDuringDrag.y + deltaY;

            boardStateRef.current = { offset: { x: newX, y: newY }, zoom: boardStateRef.current.zoom }; 
            if (boardRef.current) {
                boardRef.current.style.transform = `translate(${newX}px, ${newY}px) scale(${boardStateRef.current.zoom})`;
            }
          }
        };

        const handleBoardInteractionEnd = async (e) => {
          if (draggingNoteId && dragStartCoords && draggedNoteInitialPos) {
            const currentZoom = boardStateRef.current.zoom; 
            const finalX = draggedNoteInitialPos.x + (e.clientX - dragStartCoords.x) / currentZoom;
            const finalY = draggedNoteInitialPos.y + (e.clientY - dragStartCoords.y) / currentZoom;
            
            const noteToUpdate = notes.find(n => n.id === draggingNoteId);
            if (noteToUpdate) {
              await room.collection('note_v2').update(draggingNoteId, {
                position: {
                  x: finalX,
                  y: finalY,
                  rotation: noteToUpdate.position?.rotation || 0
                }
              });
            }
            setDraggingNoteId(null);
            setDragStartCoords(null);
            setDraggedNoteInitialPos(null);
            setCurrentDragOffset({ x: 0, y: 0 });
          }

          if (isPinching || isBoardDragging) {
            setBoardOffset(boardStateRef.current.offset);
            setZoom(boardStateRef.current.zoom); 
          }

          setIsPinching(false);
          setInitialPinchDistance(0);
          setInitialPinchMidpoint(null);
          setInitialBoardStateForPinch(null);

          setIsBoardDragging(false);
          setBoardDragStartCoords(null);
          setInitialBoardOffsetDuringDrag(null);
        };

        window.addEventListener('mousemove', handleBoardInteractionMove);
        window.addEventListener('mouseup', handleBoardInteractionEnd);
        window.addEventListener('touchmove', handleBoardInteractionMove, { passive: false }); 
        window.addEventListener('touchend', handleBoardInteractionEnd);
        window.addEventListener('touchcancel', handleBoardInteractionEnd); 

        return () => {
          window.removeEventListener('mousemove', handleBoardInteractionMove);
          window.removeEventListener('mouseup', handleBoardInteractionEnd);
          window.removeEventListener('touchmove', handleBoardInteractionMove, { passive: false });
          window.removeEventListener('touchend', handleBoardInteractionEnd);
          window.removeEventListener('touchcancel', handleBoardInteractionEnd);
        };
      }, [
        draggingNoteId, dragStartCoords, draggedNoteInitialPos, notes, 
        isBoardDragging, boardDragStartCoords, initialBoardOffsetDuringDrag, 
        isPinching, initialPinchDistance, initialPinchMidpoint, initialBoardStateForPinch, 
        MIN_ZOOM, MAX_ZOOM 
      ]);

      const handleWheel = React.useCallback((e) => {
        if (showArchives || selectedArchive || showCommandsAsModal) { 
            return;
        }

        e.preventDefault(); 

        const { offset, zoom: currentZoom } = boardStateRef.current;
        const viewportRect = viewportRef.current.getBoundingClientRect();
        
        const cursorX = e.clientX - viewportRect.left;
        const cursorY = e.clientY - viewportRect.top;

        const boardX = (cursorX - offset.x) / currentZoom;
        const boardY = (cursorY - offset.y) / currentZoom;

        let newZoom = currentZoom * (1 + (e.deltaY > 0 ? -1 : 1) * ZOOM_SPEED);
        newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));
        newZoom = parseFloat(newZoom.toFixed(2)); 

        const newOffsetX = cursorX - (boardX * newZoom);
        const newOffsetY = cursorY - (boardY * newZoom);

        setZoom(newZoom);
        setBoardOffset({ x: newOffsetX, y: newOffsetY });
      }, [showArchives, selectedArchive, showCommandsAsModal, ZOOM_SPEED, MIN_ZOOM, MAX_ZOOM]); 

      React.useEffect(() => {
        const viewportEl = viewportRef.current;
        if (viewportEl) {
          viewportEl.addEventListener('wheel', handleWheel, { passive: false });
        }
        return () => {
          if (viewportEl) {
            viewportEl.removeEventListener('wheel', handleWheel);
          }
        };
      }, [handleWheel]);

      const waitForAllMediaToLoad = (element) => {
          return new Promise(resolve => {
              const mediaElements = Array.from(element.querySelectorAll('img, video'));
              if (mediaElements.length === 0) {
                  resolve();
                  return;
              }

              let loadedCount = 0;
              const totalMedia = mediaElements.length;

              const checkLoaded = () => {
                  loadedCount++;
                  if (loadedCount === totalMedia) {
                      resolve();
                  }
              };

              mediaElements.forEach(media => {
                  if (media.tagName === 'IMG') {
                      if (media.complete && media.naturalHeight !== 0) { 
                          checkLoaded();
                      } else {
                          media.onload = checkLoaded;
                          media.onerror = (e) => {
                              console.warn('Image failed to load in archive capture:', media.src, e);
                              checkLoaded(); 
                          };
                      }
                  } else if (media.tagName === 'VIDEO') {
                      if (media.readyState >= 3) { 
                          checkLoaded();
                      } else {
                          media.onloadedmetadata = checkLoaded;
                          media.onerror = (e) => {
                              console.warn('Video failed to load in archive capture:', media.src, e);
                              checkLoaded(); 
                          };
                      }
                  }
              });
          });
      };

      const isSuspiciousLink = (text) => {
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        let match;
        while ((match = urlRegex.exec(text)) !== null) {
          try {
            const url = new URL(match[0]);
            const hostname = url.hostname;
            if (hostname.includes('tiny.cc') || hostname.includes('bit.ly') || hostname.includes('bitly.com')) {
              return true; 
            }
          } catch (e) {
            console.warn("Invalid URL detected during scan:", match[0], e);
            // Ignore invalid URLs for this check, or handle as desired
          }
        }
        return false; 
      };

      const replaceEmojiCommands = async (text) => {
        const emojiCommandRegex = /!emoji\s+(.+)/g; 
        let originalOrderMatches = [];
        
        text.replace(emojiCommandRegex, (fullMatch, expression, index) => {
            originalOrderMatches.push({ fullMatch, expression, index });
            return fullMatch; 
        });

        if (originalOrderMatches.length === 0) {
            return text; 
        }

        const emojiPromises = originalOrderMatches.map(m => generateEmoji(m.expression));
        const generatedEmojis = await Promise.all(emojiPromises);

        let resultText = text;
        for (let i = originalOrderMatches.length - 1; i >= 0; i--) {
            const m = originalOrderMatches[i];
            const emoji = generatedEmojis[i]; 
            resultText = resultText.substring(0, m.index) + emoji + resultText.substring(m.index + m.fullMatch.length);
        }
        return resultText;
      };

      const processSelectedFile = async (file) => {
        if (!file) return;

        attemptPlayAudio(); 

        const fileType = file.type;

        if (fileType.startsWith('image/')) { 
            setSelectedImageFile(file);
            setSelectedVideoFile(null); 
        } else if (fileType.startsWith('video/mp4')) {
            setSelectedImageFile(null); 
            setSelectedVideoFile(null); 

            const MAX_VIDEO_SIZE_MB = 50; 
            if (file.size > MAX_VIDEO_SIZE_MB * 1024 * 1024) { 
                alert(`Video file is too large. Max ${MAX_VIDEO_SIZE_MB}MB.`);
                return;
            }

            const videoURL = URL.createObjectURL(file);
            const videoElement = document.createElement('video'); 
            videoElement.preload = 'metadata'; 

            videoElement.onloadedmetadata = async () => {
                URL.revokeObjectURL(videoURL); 

                const MAX_VIDEO_DURATION_SECONDS = 30;
                if (videoElement.duration > MAX_VIDEO_DURATION_SECONDS) {
                    alert(`Video is too long. Max ${MAX_VIDEO_DURATION_SECONDS} seconds.`);
                    return; 
                }
                
                setSelectedVideoFile(file);
            };

            videoElement.onerror = (errorEvent) => {
                URL.revokeObjectURL(videoURL);
                console.error("Error loading video metadata:", errorEvent);
                alert("Failed to load video. Please ensure it's a valid MP4.");
            };
            videoElement.src = videoURL; 
        } else {
            alert('Please drop an image file (JPG, PNG, GIF, WebP) or an MP4 video (max 30 seconds).');
            setSelectedImageFile(null);
            setSelectedVideoFile(null);
        }
      };

      const handleCreateNote = async () => {
        if (isGeneratingAIImage) { 
            alert("An AI operation is already in progress. Please wait.");
            return;
        }

        attemptPlayAudio(); 

        const AI_IMAGE_COMMAND_PREFIX = '!ai ';
        if (newNoteText.startsWith(AI_IMAGE_COMMAND_PREFIX)) {
            const promptText = newNoteText.substring(AI_IMAGE_COMMAND_PREFIX.length).trim();
            if (!promptText) { alert("Please provide a prompt after !ai"); return; }
            setIsGeneratingAIImage(true);
            const { offset, zoom } = boardStateRef.current;
            const cx = window.innerWidth/2, cy = window.innerHeight/2;
            const wx = (cx - offset.x)/zoom, wy = (cy - offset.y)/zoom;
            try {
              const aiImageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(promptText)}`;
              const newNote = {
                id: generateId(),
                text: `AI Generated: "${promptText}"`,
                mediaUrl: aiImageUrl,
                mediaType: 'image',
                position: { x: wx, y: wy, rotation: (Math.random()-0.5)*10 }
              };
              setNotes(prev => [...prev, newNote]);
            } catch (err) {
              console.error("AI error:", err);
              alert("Failed to generate image. Try again.");
            } finally {
              setIsGeneratingAIImage(false);
            }
            setNewNoteText('');
            return;
        }

        const AI_EMOJI_COMMAND_PATTERN = /!emoji\s+(.+)/g;
        let finalNoteText = newNoteText;
        if (AI_EMOJI_COMMAND_PATTERN.test(newNoteText)) { 
            setIsGeneratingAIImage(true); 
            try {
                finalNoteText = await replaceEmojiCommands(newNoteText); 
            } catch (error) {
                console.error("Error processing emoji commands for note:", error);
                alert("Failed to process emoji commands. Please try again.");
                setIsGeneratingAIImage(false);
                return; 
            } finally {
                setIsGeneratingAIImage(false);
            }
        }

        if (isSuspiciousLink(finalNoteText)) {
            alert("Suspicious link detected! Links from tiny.cc or bit.ly are not allowed.");
            return;
        }

        let mediaUrl = null;
        let mediaType = null;

        if (selectedImageFile) {
          mediaType = 'image';
          mediaUrl = await new Promise(r => {
            const fr = new FileReader();
            fr.onload = () => r(fr.result);
            fr.readAsDataURL(selectedImageFile);
          });
        } else if (selectedVideoFile) {
          mediaType = 'video';
          mediaUrl = await new Promise(r => {
            const fr = new FileReader();
            fr.onload = () => r(fr.result);
            fr.readAsDataURL(selectedVideoFile);
          });
        }
        
        if (!finalNoteText.trim() && !mediaUrl) {
            alert("Please enter some text, drag/drop an image/video, or use an AI command.");
            return;
        }

        const { offset, zoom } = boardStateRef.current;
        const cx = window.innerWidth/2, cy = window.innerHeight/2;
        const wx = (cx - offset.x)/zoom, wy = (cy - offset.y)/zoom;

        const randomOffset = {
          x: (Math.random() - 0.5) * 200, 
          y: (Math.random() - 0.5) * 200
        };
        
        const newNote = {
          id: generateId(),
          text: finalNoteText,
          mediaUrl,
          mediaType,
          position: {
            x: wx + randomOffset.x,
            y: wy + randomOffset.y,
            rotation: (Math.random()-0.5)*10
          }
        };
        setNotes(prev => [...prev, newNote]);
        
        setNewNoteText('');
        setSelectedImageFile(null); 
        setSelectedVideoFile(null); 
      };

      const handleArchive = async () => {
        if (!boardRef.current) {
            console.error("Corkboard element not found for archiving.");
            return;
        }

        await waitForAllMediaToLoad(boardRef.current);

        const canvas = await html2canvas(boardRef.current, { 
            scale: 0.5, 
            useCORS: true 
        }); 
        
        const date = new Date();
        const filename = `corkboard-${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}_${String(date.getHours()).padStart(2, '0')}-${String(date.getMinutes()).padStart(2, '0')}.png`;
        
        const link = document.createElement('a');
        link.download = filename;
        link.href = canvas.toDataURL('image/png');
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        const dataUrl = canvas.toDataURL('image/png');
        const newArchive = {
          id: generateId(),
          imageUrl: dataUrl,
          timestamp: date.toISOString()
        };
        setArchives(prev => [...prev, newArchive]);
      };

      const handleCommand = (command) => {
        switch (command) {
          case 'toggleMusic': 
            toggleAudio();
            break;
          case 'skipMusic': 
            skipAudio();
            break;
          case 'archive':
            handleArchive();
            break;
          case 'viewArchives': 
            setShowArchives(true); 
            break;
        }
      };

      const handleFileSelect = (e) => {
        const file = e.target.files[0];
        processSelectedFile(file);
        e.target.value = ''; 
      };

      const handleDragOver = (e) => {
        e.preventDefault(); 
        e.stopPropagation(); 
        setIsDragOver(true);
      };

      const handleDragLeave = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragOver(false);
      };

      const handleDrop = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragOver(false); 

        const files = e.dataTransfer.files;
        if (files.length > 0) {
            processSelectedFile(files[0]);
        }
      };

      const renderTextWithLinks = (text) => {
        if (typeof text !== 'string' || text === null || text === undefined) {
          return { __html: '' }; 
        }

        const urlRegex = /(https?:\/\/[^\s]+)/g;
        const parts = [];
        let lastIndex = 0;
        let match;

        while ((match = urlRegex.exec(text)) !== null) {
          const url = match[0];
          const startIndex = match.index;
          const endIndex = urlRegex.lastIndex;

          if (startIndex > lastIndex) {
            parts.push(text.substring(lastIndex, startIndex));
          }

          parts.push(
            `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`
          );
          lastIndex = endIndex;
        }

        if (lastIndex < text.length) {
            parts.push(text.substring(lastIndex));
        }

        return { __html: parts.join('') };
      };

      return (
        <>
          <div id="darkness-overlay" ref={darknessOverlayRef}></div> 
          <Chat
            chatMessages={chatMessages}
            onSendChat={handleSendChat}
            onCommand={handleCommand}
            onMinimize={() => setIsChatMinimized(!isChatMinimized)}
            isMinimized={isChatMinimized}
            username={username}
          />
          
          {isChatMinimized && (
            <div className="chat-minimized-button" onClick={() => setIsChatMinimized(false)}>
              💬
            </div>
          )}

          {isMobile ? (
            <>
              {!showCommandsAsModal && (
                <div className="command-minimized-button" onClick={() => setShowCommandsAsModal(true)}>
                  ❓
                </div>
              )}
              {showCommandsAsModal && (
                <div className="command-modal-overlay" onClick={() => setShowCommandsAsModal(false)}>
                  <div className="command-modal-content" onClick={(e) => e.stopPropagation()}>
                    <div className="command-modal-header">
                      <h3>Commands</h3>
                      <button className="command-modal-close" onClick={() => setShowCommandsAsModal(false)}>×</button>
                    </div>
                    <div className="command-list-content">
                      <strong>Available Commands:</strong>
                      <div><strong>!ai &lt;prompt&gt;</strong> - Generate an image with AI</div>
                      <div><strong>!emoji &lt;expression&gt;</strong> - Insert an AI-generated emoji</div>
                      <div><strong>!pause</strong> - Toggle music</div>
                      <div><strong>!skip</strong> - Skip current song</div>
                      <div><strong>/archive board</strong> - Save current board state</div>
                      <div><strong>/archive view</strong> - Open archived boards</div>
                    </div>
                  </div>
                </div>
              )}
            </>
          ) : (
            <div className="command-list-container">
              <strong>Available Commands:</strong>
              <div><strong>!ai &lt;prompt&gt;</strong> - Generate an image with AI</div>
              <div><strong>!emoji &lt;expression&gt;</strong> - Insert an AI-generated emoji</div>
              <div><strong>!pause</strong> - Toggle music</div>
              <div><strong>!skip</strong> - Skip current song</div>
              <div><strong>/archive board</strong> - Save current board state</div>
              <div><strong>/archive view</strong> - Open archived boards</div>
            </div>
          )}

          <div id="viewport" ref={viewportRef} className={isBoardDragging || isPinching ? 'dragging' : ''} 
               onMouseDown={handleBoardInteractionStart}
               onTouchStart={handleBoardInteractionStart}
          >
            <div id="corkboard" ref={boardRef} 
                 style={{ 
                    transform: `translate(${boardOffset.x}px, ${boardOffset.y}px) scale(${zoom})`, 
                    width: '10000px', 
                    height: '10000px' 
                 }}
            >
              {notes.map((note) => {
                let currentX = note.position?.x || 50;
                let currentY = note.position?.y || 50;
                let currentRotation = note.position?.rotation || 0;

                if (draggingNoteId === note.id && draggedNoteInitialPos) {
                  currentX = draggedNoteInitialPos.x + currentDragOffset.x;
                  currentY = draggedNoteInitialPos.y + currentDragOffset.y;
                  currentRotation = draggedNoteInitialPos.rotation; 
                }

                return (
                  <div
                    key={note.id}
                    className={`post-it ${selectedNote?.id === note.id ? 'selected' : ''}`}
                    onMouseDown={(e) => handleNoteMouseDown(e, note)} 
                    onTouchStart={(e) => handleNoteMouseDown(e, note)} 
                    style={{
                      left: `${currentX}px`, 
                      top: `${currentY}px`,
                      '--rotation': `${currentRotation}deg`,
                      zIndex: draggingNoteId === note.id ? 2001 : (selectedNote?.id === note.id ? 2000 : 1)
                    }}
                  >
                    <div className="username">{note.username}</div>
                    <div className="text" dangerouslySetInnerHTML={renderTextWithLinks(note.text || '')}></div>
                    {note.mediaType === 'image' && note.mediaUrl && <img src={note.mediaUrl} alt="Note content" className="note-image" />}
                    {note.mediaType === 'video' && note.mediaUrl && (
                        <video src={note.mediaUrl} controls muted loop playsInline className="note-image" />
                    )}
                  </div>
                );
              })}
            </div>
          </div>

          <div className="note-pile">
            <div 
              className={`new-note ${isDragOver ? 'drag-over' : ''}`}
              onDragOver={handleDragOver}
              onDrop={handleDrop}
              onDragLeave={handleDragLeave}
            >
              <textarea
                value={newNoteText}
                onChange={(e) => setNewNoteText(e.target.value)}
                placeholder={isGeneratingAIImage ? "AI generating... please wait." : "Write your note here, or drag & drop an image/video, or type !ai <prompt> or !emoji <expression>"}
                disabled={isGeneratingAIImage}
                onKeyPress={(e) => {
                  if (e.key === 'Enter' && !e.shiftKey && !isGeneratingAIImage) {
                    e.preventDefault();
                    handleCreateNote();
                  }
                }}
              />
              <div className="new-note-actions">
                {isMobile && ( 
                  <>
                    <input
                      type="file"
                      accept="image/*,video/mp4"
                      onChange={handleFileSelect}
                      ref={fileInputRef}
                      style={{ display: 'none' }} 
                    />
                    <button onClick={() => fileInputRef.current.click()} disabled={isGeneratingAIImage}>
                      Upload Media
                    </button>
                  </>
                )}
                {(selectedImageFile || selectedVideoFile) && ( 
                  <span className="file-name-preview">
                    Media: {(selectedImageFile?.name || selectedVideoFile?.name)}
                  </span>
                )}
                <button onClick={handleCreateNote} disabled={isGeneratingAIImage}>
                  {isGeneratingAIImage ? 'Generating...' : 'Post Note'}
                </button>
              </div>
            </div>
          </div>

          <div className="key-controls">
            {selectedNote ? 
              "Note selected: Drag with mouse/touch, Arrow keys to move, R to rotate, ESC to deselect" :
              "Use mouse/touch to drag notes/board, Arrow keys to navigate board, Scroll to zoom"
            }
          </div>

          {showArchives && (
            <div className="archive-modal-overlay" onClick={() => setShowArchives(false)}>
              <div className="archive-modal-content" onClick={(e) => e.stopPropagation()}> 
                <div className="archive-modal-header">
                  <h3>Archived Boards</h3>
                  <button className="archive-modal-close" onClick={() => setShowArchives(false)}>×</button>
                </div>
                <div className="archive-list">
                  {archives.length === 0 ? (
                    <p style={{ color: '#aaa', textAlign: 'center', gridColumn: '1 / -1' }}>No archives yet. Use "/archive board" to save one!</p>
                  ) : (
                    archives.map((archive) => (
                      <div 
                        key={archive.id} 
                        className="archive-preview-item"
                        onClick={(e) => { e.stopPropagation(); setSelectedArchive(archive); }}
                        onTouchStart={(e) => { e.stopPropagation(); setSelectedArchive(archive); }} 
                      >
                        <img src={archive.imageUrl} alt="Board archive" />
                        <div className="archive-timestamp">
                          {new Date(archive.timestamp).toLocaleString()}
                        </div>
                      </div>
                    ))
                  )}
                </div>
              </div>
            </div>
          )}

          {selectedArchive && (
            <div 
              className="selected-archive-full-view"
              onClick={() => setSelectedArchive(null)}
              onTouchStart={() => setSelectedArchive(null)} 
            >
              <img 
                src={selectedArchive.imageUrl} 
                alt="Archive full view"
              />
            </div>
          )}
        </>
      );
    }

    ReactDOM.createRoot(document.getElementById('app')).render(<CorkBoard />);
  </script>
</body>
</html>
