<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Board Database (Supabase Backend)</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: monospace;
      background: #f5f5f5;
      color: #333;
      line-height: 1.6;
    }
    h2 {
      margin-top: 0;
      color: #2c3e50;
      font-size: 1.5em;
    }
    #board-data {
      white-space: pre-wrap;
      word-wrap: break-word;
      background: #fff;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
      min-height: 120px;
      overflow-x: auto;
      font-size: 0.85em;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .status-messages {
      margin-top: 15px;
      min-height: 25px;
    }
    .status-message {
      margin-bottom: 8px;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 0.9em;
      font-weight: bold;
      transition: opacity 0.3s ease-out;
    }
    .status-success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
    .status-error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
    .status-info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
    .status-warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba; }
    /* Style for the new button */
    .action-button {
      background-color: #f44336; /* Red background */
      color: white; /* White text */
      padding: 10px 15px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      margin-top: 20px;
      transition: background-color 0.3s ease;
    }
    .action-button:hover {
      background-color: #d32f2f; /* Darker red on hover */
    }
  </style>
</head>
<body>
  <h2>Stored Board Data (Supabase Backend)</h2>
  <div id="status-messages"></div>
  <pre id="board-data">Loadingâ€¦</pre>

  <button id="clear-data-button" class="action-button">Clear All Board Data</button>

  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';

    const supabaseUrl = 'https://gtmpsjiuqyqjonlzjuhz.supabase.co';
    const supabaseAnonKey = 'sb_publishable_lBme1W769_h523sdzlpGuw_Aqm4qcdv';

    const supabase = createClient(supabaseUrl, supabaseAnonKey);

    const BOARD_TABLE_NAME = 'board_data';
    const GLOBAL_BOARD_ROW_ID = 1;
    const ADMIN_PASSWORD = 'hiwhyguy3911'; // The password to clear data

    let boardData = {
      notes: [],
      chatMessages: [],
      archives: []
    };

    function displayBoardData() {
      const pre = document.getElementById('board-data');
      pre.textContent = JSON.stringify(boardData, null, 2);
    }

    function showStatus(message, type) {
        const statusDiv = document.getElementById('status-messages');
        const msgElement = document.createElement('div');
        msgElement.className = `status-message status-${type}`;
        msgElement.textContent = message;
        statusDiv.appendChild(msgElement);
        setTimeout(() => msgElement.remove(), 5000);
    }

    async function fetchBoardDataFromSupabase() {
      try {
        const { data, error } = await supabase
          .from(BOARD_TABLE_NAME)
          .select('data')
          .eq('id', GLOBAL_BOARD_ROW_ID)
          .single();

        if (error && error.code !== 'PGRST116') {
            throw error;
        }

        if (data && data.data) {
          // Merge incoming data from Supabase into our client-side 'boardData'.
          // This "never erase" logic is crucial for ensuring client-side state is enriched.
          for (const key in data.data) {
              if (Object.hasOwnProperty.call(data.data, key) && data.data[key] !== undefined) {
                  boardData[key] = data.data[key];
              }
          }
          showStatus('Board data fetched from Supabase successfully.', 'success');
        } else {
            showStatus('No board data found in Supabase for ID ' + GLOBAL_BOARD_ROW_ID + '. Initializing with empty board.', 'warning');
        }

        // Ensure primary properties of 'boardData' are always initialized as arrays.
        if (!Array.isArray(boardData.notes)) boardData.notes = [];
        if (!Array.isArray(boardData.chatMessages)) boardData.chatMessages = [];
        if (!Array.isArray(boardData.archives)) boardData.archives = [];

        displayBoardData();
        return boardData;
      } catch (error) {
        console.error('Error fetching board data from Supabase:', error.message);
        showStatus(`Error fetching board data: ${error.message}`, 'error');
        return boardData;
      }
    }

    /**
     * Asynchronously sends updated board data to Supabase.
     * It now intelligently merges arrays, appending new items, and overwrites other properties.
     * @param {Object} dataToMerge The partial data received from the parent frame to be merged.
     * Example: { notes: [{id: 123, content: "New Note"}] }
     */
    async function sendBoardDataToSupabase(dataToMerge) {
      try {
        // Step 1: Fetch the current complete board data from Supabase.
        // This is crucial to ensure that any changes made by other clients, or
        // fields not included in 'dataToMerge', are preserved.
        const { data: currentSupabaseRow, error: fetchError } = await supabase
          .from(BOARD_TABLE_NAME)
          .select('data')
          .eq('id', GLOBAL_BOARD_ROW_ID)
          .single();

        let existingSupabaseData = {};
        if (currentSupabaseRow && currentSupabaseRow.data) {
            existingSupabaseData = currentSupabaseRow.data;
        } else if (fetchError && fetchError.code === 'PGRST116') {
            // No row found, start with default empty arrays to prevent errors
            existingSupabaseData = { notes: [], chatMessages: [], archives: [] };
        } else if (fetchError) {
            throw fetchError; // If it's a real error other than "no rows found", throw it.
        }

        // Ensure existing arrays are initialized if they don't exist
        if (!Array.isArray(existingSupabaseData.notes)) existingSupabaseData.notes = [];
        if (!Array.isArray(existingSupabaseData.chatMessages)) existingSupabaseData.chatMessages = [];
        if (!Array.isArray(existingSupabaseData.archives)) existingSupabaseData.archives = [];


        // Step 2: Perform the intelligent merge logic.
        // Create a new object for the merged data, starting with the existing DB data.
        const mergedDataForSupabase = { ...existingSupabaseData };

        for (const key in dataToMerge) {
            if (Object.hasOwnProperty.call(dataToMerge, key)) {
                // Special handling for array properties: append unique new items
                if (key === 'notes' && Array.isArray(dataToMerge.notes)) {
                    // Create a Set of existing note IDs to prevent duplicates
                    const existingNoteIds = new Set(mergedDataForSupabase.notes.map(note => note.id));
                    dataToMerge.notes.forEach(newNote => {
                        if (!existingNoteIds.has(newNote.id)) {
                            mergedDataForSupabase.notes.push(newNote);
                        }
                    });
                } else if (key === 'chatMessages' && Array.isArray(dataToMerge.chatMessages)) {
                    // Assuming chat messages might not have unique IDs, simple concatenation
                    mergedDataForSupabase.chatMessages.push(...dataToMerge.chatMessages);
                } else if (key === 'archives' && Array.isArray(dataToMerge.archives)) {
                    // Assuming archives might not have unique IDs, simple concatenation
                    mergedDataForSupabase.
